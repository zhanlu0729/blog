## 对事物本质的认识
1. **Docker容器的本质** 就是进程
2. **Pod的本质** 就是容器
3. **编写线程安全代码的本质** 就是管理对状态的访问
4. **简单的本质** 不是更容易使用，也不是看上去更容易懂，而是其中再无多余的东西可以丢弃

### 多线程概念
1. **共享** 是指一个变量可以多个线程访问
2. **可变** 是指一个变量的值在其生命周期内可以被改变
3. **类是线程安全的** 是指在被多个线程访问时，类可以持续进行正确的行为
4. **无状态对象永远是线程安全的**
5. **竞态条件** 产生的条件：当计算的正确性依赖运行时中相关的时序或多线程交替时
6. 为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量
7. **锁** 不仅仅是关于同步和互斥的，也是关于内存可见性的。为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。
8. **Volatile** 当验证正确性必须推断可见性问题时，应用避免使用volatile变量；正确使用volatile变量的方式包括：用于确保他们所引用的对象状态的可见性，或者用于标识正确的生命周期事件(初始化或关闭)的发生。
9. 加锁可以保证可见性与原子性；volatile变量只能保证可见性。
10. **发布** 一个对象的意思是使它能够被当前范围之外的代码所使用，最常见的发布对象的方式是将对象的引用存储到公共静态域中。
11. **不要让this引用在构造期间溢出**。
12. **线程封闭技术** 是实现线程安全最简单的方式之一。当对象封闭在一个线程中时，这种做法会自动成为线程安全的，即使被封闭的对象本身并不是。
13. **Ad-hoc线程限制** 是指维护线程限制性的任务全部落在实现上的这种情况。
14. **栈限制** 是线程限制的一种特例，在栈限制中，只能通过本地变量才可以触及对象。
15. **不可变对象** 永远是线程安全，不可变性并不是简单的等于将对象的所有域都声明为final类型，所有域都是final类型的对象仍然是可以可变的，因为final域可以获得一个可以获得一个到可变对象的引用；只有满足如下状态，一个对象才是不可变的：
  - a.它的状态不能在创建后再修改；
  - b.所有域都是final类型，并且它被正确的创建(创建期间没有发生this引用的溢出)。
16. 正如“将所有的域声明为私有，除非他们需要更高的可见性”一样，“将所有的域声明为final，除非他们是可变的”，也是一条良好的实践。
17. **即使发布对象引用时没有使用同步**，不可变对象仍然可以被安全的访问。
18. **不可变对象可以在没有额外同步的情况下，安全地用于任意线程；甚至发布他们时亦不需要同步**。
19. 为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正解创建的对象可以通过以下条件安全的发布：
  - a.通过静态初始化器初始化对象的引用；
  - b.将它的引用存储到volatile域或者AtomicReference域中、将它的引用存储到正确创建的对象的final域中、或者将它的引用存储到由锁正确保护的域中。
20. **任何线程都可以在没有额外同步下安全地使用一个安全发布的高效不可变对象。
21. **发布对象的必要条件依赖对象的可变性**：- a.不可变对象可以通过任意机制发布；- b.高效不可变对象必须要安全发布；- c.可变对象必须要安全发布，同时必须要线程安全或被锁保护。
22. **在并发程序中，使用和共享对象的一些最有效的策略如下**：- a.线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只有被占有它的线程个性；- b.共享只读：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象；- c.共享线程安全：一个线程安全的对象在内部进行同步，所以其它线程无须额外同步，就可以通过公共接口随意地访问它；- d.被守护的：一个被守护的对象只能通过特定的锁来访问，被守护的对象包括被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。

### 第4章 组合对象
1. 不理解对象的不变约束和后验条件，你就不能保证线程安全性；要约束状态变量的有效值或者状态转换，就需要原子性与封装性。
2. 将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁。
3. 限制性使构造线程安全的类更容易，因为类的状态被限制后，分析它的线程安全时，就不必检查完整的程序。
4. 如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量。

### 第5章 构建块
1. 正如封装一个对象的状态，能够使它容易地保护不变约束一样，封装它的同步则可以迫使它符合同步策略。
2. 用并发容器替换同步容器，这种做法以很小风险带来了可扩展性显著的提高。
3. 有界队列是强大的资源管理工具，用来建立可靠的应用程序：他们遏制那些可以产生过多工作量、具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮。
4. **闭锁** 是一种Synchronizer，它可以延迟线程的进度直到线程到达终止状态。
5. **信号量** 用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。信号量可以用来实现资源池或给一个容器限定边界。
6. **关卡** 类似于闭锁，它能够阻塞一组线程，直到某些事件发生。其中关卡与闭锁的关键不同在于，所有线程必须同时到达关卡点，才能继续处理。闭锁等待的是事件，而关卡等待的是其他线程。

## 第一部分总结
1. 所有并发问题都归结为如何协调访问并发状态。可就状态越少，保证保证线程安全就越容易。
2. 尽量将域声明为final类型，除非他们的需要是可变的。
3. 不可变对象天生就是线程安全。
4. 封装使管理复杂度变得可行。在对象中封装数据，让它们更加容易地保持不变；在对象中封装同步，使它更加容易地遵守同步策略。
5. 用锁来守护每一个可变变量。
6. 对同一不变约束中的所有变量都使用相同的锁。
7. 在运行复合操作期间持有锁。
8. 在非同步的多线程情况下，访问可变变量的程序是存在隐患的。
9. 不要依赖于可以需要同步的小聪明。
10. 在设计过程中就考虑线程安全，或者在文档中明确说明它不是线程安全的。
11. 文档化你的同步策略。

### 第6章 任务执行
1. **任务** 就是抽象、离散的工作单元。
2. 大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升。
3. 调用interrupt并不意味着必然停止目标线程正在进行的工作，它仅仅传递了请求中断的消息；中断通常是实现取消最明智的选择。
4. 因为每个线程都其自己的中断策略，所以你不应该中断线程，除非你知道中断对这个线程意味着什么。
5. 只有实现了线程中断策略的代码才可以接受中断请求；通用目的的任务和库的代码绝不应该接受中断请求。
6. 对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法。
7. 在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中。
8. 应用程序中，守护线程不能替代对服务的生命周期恰当、良好的管理。
9. 当每个迭代彼此独立，并且完成循环中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的。
10. 如果所有的线程以通用的固定秩序获得锁，程序就不会出现锁顺序死锁问题了。
11. 在持有锁的时候调用外部方法是在挑战活跃性问题；外部方法可能会获得其它锁(产生死锁的风险)，或者遭遇严重超时的阻塞，当你持有锁的时候会延迟其它试图获得该锁的线程。
12. 在程序中尽量使用开放调用，依赖于开放调用的程序，相比那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度的分析。
13. 抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。大多数并发应用程序可以对所有线程使用相同的优先级。
14. **可伸缩性**指的是，当增加计算资源的时候(比如增加额外CPU数量、内存、存储器、I/O带宽)，吞吐量和生产量能够相应地得以改进。
15. 避免不成熟的优化；首先使程序正确，然后再加快--如果它运行得还不够快。
16. 所有的并发程序都有一些串行源；如果你认为你没有，那么去仔细检查吧。
17. 并发程序中，对可伸缩性首要的威胁是独占的资源锁。有两个原因影响锁的竞争性：
18. 要内部锁不能满足使用时，ReentrantLock才被作为更高级的工具；当你需要以下高级特性时，才应该使用：可定时的、可轮询的与可中断的锁获取操作，公平队列或者非块结构的锁；否则，请使用synchronized。
19. 无论何时，当你在等待一个条件，一定确保有人在条件谓词变为真时通知你。
